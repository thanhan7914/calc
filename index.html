<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T√≠nh to√°n s·ªë l∆∞·ª£ng h√†ng h√≥a</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .input-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1rem;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .products-section {
            background: white;
            border: 2px solid #e0e6ed;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 1.4rem;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .product-item {
            background: #f8f9fa;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .product-item:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .product-row {
            display: grid;
            grid-template-columns: 2fr 1fr auto;
            gap: 15px;
            align-items: end;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #2c3e50);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #219a52);
            color: white;
        }
        
        .btn-success:hover {
            background: linear-gradient(135deg, #219a52, #1e8449);
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 8px 16px;
            font-size: 0.9rem;
        }
        
        .btn-danger:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
        }
        
        .results {
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            border-radius: 10px;
            padding: 25px;
            margin-top: 30px;
        }
        
        .results-title {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .result-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .result-table th {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .result-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e6ed;
        }
        
        .result-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .result-table tr:hover {
            background: #e3f2fd;
        }
        
        .total-row {
            background: linear-gradient(135deg, #3498db, #2980b9) !important;
            color: white !important;
            font-weight: bold;
        }
        
        .total-row td {
            border: none !important;
        }
        
        .error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 600;
        }
        
        .success {
            background: linear-gradient(135deg, #27ae60, #219a52);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 600;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .product-row {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>üßÆ T√≠nh to√°n s·ªë l∆∞·ª£ng h√†ng h√≥a</h1>
                <p>Nh·∫≠p ƒë∆°n gi√° v√† t·ªïng ti·ªÅn ƒë·ªÉ t√≠nh to√°n s·ªë l∆∞·ª£ng c·∫ßn xu·∫•t</p>
            </div>
            
            <div class="content">
                <!-- Ph·∫ßn nh·∫≠p t·ªïng ti·ªÅn -->
                <div class="input-section">
                    <div class="form-group">
                        <label for="totalAmount">üí∞ T·ªïng ti·ªÅn thanh to√°n (ƒë√£ bao g·ªìm VAT):</label>
                        <input 
                            type="number" 
                            id="totalAmount"
                            v-model="totalAmount" 
                            placeholder="V√≠ d·ª•: 4169000"
                            min="0"
                        >
                    </div>
                    
                    <div class="form-group">
                        <label for="vatRate">üìä Thu·∫ø su·∫•t VAT (%):</label>
                        <input 
                            type="number" 
                            id="vatRate"
                            v-model="vatRate" 
                            placeholder="V√≠ d·ª•: 10"
                            min="0"
                            max="100"
                        >
                    </div>
                </div>
                
                <!-- Ph·∫ßn danh s√°ch s·∫£n ph·∫©m -->
                <div class="products-section">
                    <h2 class="section-title">
                        üì¶ Danh s√°ch m·∫∑t h√†ng
                    </h2>
                    
                    <div v-for="(product, index) in products" :key="index" class="product-item">
                        <div class="product-row">
                            <div class="form-group">
                                <label>T√™n h√†ng h√≥a:</label>
                                <input 
                                    type="text" 
                                    v-model="product.name" 
                                    :placeholder="'S·∫£n ph·∫©m ' + (index + 1)"
                                    style="border: 2px solid #e0e6ed; padding: 12px; border-radius: 8px; width: 100%;"
                                >
                            </div>
                            <div class="form-group">
                                <label>ƒê∆°n gi√° (VNƒê):</label>
                                <input 
                                    type="number" 
                                    v-model="product.price" 
                                    placeholder="Nh·∫≠p ƒë∆°n gi√°"
                                    min="0"
                                >
                            </div>
                            <button 
                                @click="removeProduct(index)" 
                                class="btn btn-danger"
                                v-if="products.length > 1"
                            >
                                üóëÔ∏è X√≥a
                            </button>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button @click="addProduct" class="btn btn-primary">
                            ‚ûï Th√™m m·∫∑t h√†ng
                        </button>
                        <button @click="calculate" class="btn btn-success">
                            üßÆ T√≠nh to√°n s·ªë l∆∞·ª£ng
                        </button>
                    </div>
                </div>
                
                <!-- Hi·ªÉn th·ªã k·∫øt qu·∫£ -->
                <div v-if="showResults" class="results">
                    <h2 class="results-title">üìã K·∫øt qu·∫£ t√≠nh to√°n</h2>
                    
                    <div v-if="errorMessage" class="error">
                        {{ errorMessage }}
                    </div>
                    
                    <div v-else-if="successMessage" class="success">
                        {{ successMessage }}
                    </div>
                    
                    <table v-if="calculatedResults.length > 0" class="result-table">
                        <thead>
                            <tr>
                                <th>STT</th>
                                <th>T√™n h√†ng h√≥a</th>
                                <th>ƒê∆°n gi√° (VNƒê)</th>
                                <th>S·ªë l∆∞·ª£ng</th>
                                <th>Th√†nh ti·ªÅn (VNƒê)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="(result, index) in calculatedResults" :key="index">
                                <td>{{ index + 1 }}</td>
                                <td>{{ result.name }}</td>
                                <td>{{ formatNumber(result.price) }}</td>
                                <td>{{ result.quantity }}</td>
                                <td>{{ formatNumber(result.subtotal) }}</td>
                            </tr>
                            <tr class="total-row">
                                <td colspan="4"><strong>T·ªïng c·ªông</strong></td>
                                <td><strong>{{ formatNumber(calculatedResults.reduce((sum, r) => sum + r.subtotal, 0)) }}</strong></td>
                            </tr>
                            <tr class="total-row">
                                <td colspan="4"><strong>Thu·∫ø VAT ({{ vatRate }}%)</strong></td>
                                <td><strong>{{ formatNumber(vatAmount) }}</strong></td>
                            </tr>
                            <tr class="total-row">
                                <td colspan="4"><strong>T·ªïng thanh to√°n</strong></td>
                                <td><strong>{{ formatNumber(totalBeforeVAT + vatAmount) }}</strong></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    totalAmount: 4169000,
                    vatRate: 10,
                    products: [
                        { name: 'R∆∞·ª£u vang De La Rosa Rosso 750ml', price: 90000 },
                        { name: 'R∆∞·ª£u vang Marcoli Rosso 750ml', price: 90000 },
                        { name: 'R∆∞·ª£u vang Segreto Negroamaro 750ml', price: 100000 },
                        { name: 'R∆∞·ª£u vang 1933 Rosso 750ml', price: 90000 },
                        { name: 'R∆∞·ª£u vang Tolucci ƒë·ªè 14% 750ml', price: 90000 },
                        { name: 'R∆∞·ª£u Vang Francis Gillot Sauvignon Blanc 750ml', price: 60909 },
                        { name: 'R∆∞·ª£u Vang Francis Gillot Cabernet Sauvignon 750ml', price: 60000 }
                    ],
                    calculatedResults: [],
                    showResults: false,
                    errorMessage: '',
                    successMessage: ''
                }
            },
            computed: {
                totalBeforeVAT() {
                    return this.calculatedResults.reduce((sum, r) => sum + r.subtotal, 0);
                },
                vatAmount() {
                    return Math.round(this.totalBeforeVAT * this.vatRate / 100);
                }
            },
            methods: {
                addProduct() {
                    this.products.push({
                        name: '',
                        price: 0
                    });
                },
                removeProduct(index) {
                    this.products.splice(index, 1);
                },
                formatNumber(num) {
                    return new Intl.NumberFormat('vi-VN').format(num);
                },
                calculate() {
                    this.showResults = true;
                    this.errorMessage = '';
                    this.successMessage = '';
                    this.calculatedResults = [];
                    
                    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
                    if (!this.totalAmount || this.totalAmount <= 0) {
                        this.errorMessage = 'Vui l√≤ng nh·∫≠p t·ªïng ti·ªÅn h·ª£p l·ªá!';
                        return;
                    }
                    
                    if (!this.vatRate || this.vatRate < 0) {
                        this.errorMessage = 'Vui l√≤ng nh·∫≠p thu·∫ø su·∫•t VAT h·ª£p l·ªá!';
                        return;
                    }
                    
                    const validProducts = this.products.filter(p => p.name && p.price > 0);
                    if (validProducts.length === 0) {
                        this.errorMessage = 'Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt s·∫£n ph·∫©m v·ªõi ƒë∆°n gi√° h·ª£p l·ªá!';
                        return;
                    }
                    
                    // T√≠nh to√°n target t·ª´ t·ªïng ti·ªÅn (bao g·ªìm VAT)
                    const target = Math.round(this.totalAmount / (1 + this.vatRate / 100));
                    
                    // T√¨m ph∆∞∆°ng √°n t·ªëi ∆∞u
                    const result = this.findOptimalQuantities(validProducts, target);
                    
                    if (result) {
                        const actualTotal = result.total;
                        const actualVAT = Math.round(actualTotal * this.vatRate / 100);
                        const actualTotalWithVAT = actualTotal + actualVAT;
                        const error = Math.abs(actualTotalWithVAT - this.totalAmount);
                        
                        // Ki·ªÉm tra sai s·ªë < 1000 VNƒê
                        if (error < 1000) {
                            this.calculatedResults = result.products;
                            this.successMessage = `‚úÖ T√¨m ƒë∆∞·ª£c ph∆∞∆°ng √°n t·ªëi ∆∞u! Sai s·ªë: ${this.formatNumber(error)} VNƒê`;
                        } else {
                            this.errorMessage = `‚ùå Kh√¥ng t√¨m ƒë∆∞·ª£c ph∆∞∆°ng √°n v·ªõi sai s·ªë < 1,000 VNƒê. Sai s·ªë hi·ªán t·∫°i: ${this.formatNumber(error)} VNƒê`;
                        }
                    } else {
                        this.errorMessage = 'Kh√¥ng t√¨m ƒë∆∞·ª£c ph∆∞∆°ng √°n ph√π h·ª£p v·ªõi t·ªïng ti·ªÅn ƒë√£ cho. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë∆°n gi√° c√°c s·∫£n ph·∫©m.';
                    }
                },
                findOptimalQuantities(products, target) {
                    const n = products.length;
                    let validSolutions = [];
                    
                    console.log(`üîç B·∫Øt ƒë·∫ßu t√¨m ki·∫øm v·ªõi target: ${target.toLocaleString()} VNƒê`);
                    
                    // B∆∞·ªõc 1: V√©t c·∫°n t√¨m T·∫§T C·∫¢ ph∆∞∆°ng √°n c√≥ sai s·ªë < 1000 VNƒê
                    this.exhaustiveSearch(products, target, validSolutions);
                    
                    console.log(`üìä T√¨m ƒë∆∞·ª£c ${validSolutions.length} ph∆∞∆°ng √°n h·ª£p l·ªá`);
                    
                    if (validSolutions.length === 0) {
                        console.log('‚ùå Kh√¥ng t√¨m ƒë∆∞·ª£c ph∆∞∆°ng √°n n√†o c√≥ sai s·ªë < 1000 VNƒê');
                        return null;
                    }
                    
                    // B∆∞·ªõc 2: Trong c√°c ph∆∞∆°ng √°n h·ª£p l·ªá, ch·ªçn ph∆∞∆°ng √°n c√¢n b·∫±ng nh·∫•t
                    let bestSolution = validSolutions[0];
                    let bestBalance = this.calculateBalanceScore(bestSolution.quantities);
                    
                    for (let i = 1; i < validSolutions.length; i++) {
                        const balance = this.calculateBalanceScore(validSolutions[i].quantities);
                        if (balance > bestBalance) {
                            bestBalance = balance;
                            bestSolution = validSolutions[i];
                        }
                    }
                    
                    console.log(`‚úÖ Ch·ªçn ph∆∞∆°ng √°n t·ªët nh·∫•t v·ªõi ƒë·ªô c√¢n b·∫±ng: ${bestBalance.toFixed(2)}`);
                    
                    return {
                        products: products.map((product, i) => ({
                            name: product.name,
                            price: product.price,
                            quantity: bestSolution.quantities[i],
                            subtotal: bestSolution.quantities[i] * product.price
                        })),
                        total: bestSolution.total
                    };
                },
                
                exhaustiveSearch(products, target, validSolutions) {
                    const n = products.length;
                    
                    // T√≠nh gi·ªõi h·∫°n s·ªë l∆∞·ª£ng cho m·ªói s·∫£n ph·∫©m
                    const maxQuantities = products.map(p => Math.min(30, Math.ceil(this.totalAmount / p.price)));
                    
                    console.log('üéØ Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng:', maxQuantities);
                    
                    // T√¨m ki·∫øm ƒë·ªá quy v·ªõi pruning th√¥ng minh
                    const searchRecursive = (index, currentQuantities, currentTotal) => {
                        if (index === n) {
                            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán sai s·ªë VAT
                            const vat = Math.round(currentTotal * this.vatRate / 100);
                            const totalWithVAT = currentTotal + vat;
                            const error = Math.abs(totalWithVAT - this.totalAmount);
                            
                            if (error < 1000) {
                                validSolutions.push({
                                    quantities: [...currentQuantities],
                                    total: currentTotal,
                                    error: error
                                });
                                
                                if (validSolutions.length % 100 === 0) {
                                    console.log(`üìà ƒê√£ t√¨m ƒë∆∞·ª£c ${validSolutions.length} ph∆∞∆°ng √°n h·ª£p l·ªá`);
                                }
                            }
                            return;
                        }
                        
                        // Pruning: ∆∞·ªõc t√≠nh xem c√≥ th·ªÉ ƒë·∫°t ƒë∆∞·ª£c target kh√¥ng
                        const remainingProducts = n - index;
                        const minPossibleTotal = currentTotal + remainingProducts; // √≠t nh·∫•t 1 cho m·ªói s·∫£n ph·∫©m c√≤n l·∫°i
                        const maxPossibleTotal = currentTotal + products.slice(index).reduce((sum, p, i) => {
                            return sum + maxQuantities[index + i] * p.price;
                        }, 0);
                        
                        // ∆Ø·ªõc t√≠nh kho·∫£ng target c·∫ßn thi·∫øt (kh√¥ng t√≠nh VAT ch√≠nh x√°c ƒë·ªÉ pruning nhanh)
                        const roughTargetMin = this.totalAmount / (1 + this.vatRate / 100) - 2000;
                        const roughTargetMax = this.totalAmount / (1 + this.vatRate / 100) + 2000;
                        
                        if (maxPossibleTotal < roughTargetMin || minPossibleTotal > roughTargetMax) {
                            return; // Pruning
                        }
                        
                        // Th·ª≠ t·ª´ng s·ªë l∆∞·ª£ng cho s·∫£n ph·∫©m hi·ªán t·∫°i
                        for (let qty = 1; qty <= maxQuantities[index]; qty++) {
                            currentQuantities[index] = qty;
                            const newTotal = currentTotal + qty * products[index].price;
                            
                            // Pruning s·ªõm n·∫øu qu√° xa target
                            if (index < n - 2) { // Ch·ªâ pruning khi c√≤n √≠t nh·∫•t 2 s·∫£n ph·∫©m
                                const estimatedFinalTotal = newTotal + (remainingProducts - 1) * 50000; // ∆Ø·ªõc t√≠nh th√¥
                                if (Math.abs(estimatedFinalTotal - target) > target * 0.5) {
                                    continue;
                                }
                            }
                            
                            searchRecursive(index + 1, currentQuantities, newTotal);
                        }
                    };
                    
                    searchRecursive(0, new Array(n), 0);
                },
                
                calculateBalanceScore(quantities) {
                    const n = quantities.length;
                    if (n <= 1) return 100;
                    
                    const maxQty = Math.max(...quantities);
                    const minQty = Math.min(...quantities);
                    const avgQty = quantities.reduce((sum, qty) => sum + qty, 0) / n;
                    
                    // ƒêi·ªÉm c√¢n b·∫±ng d·ª±a tr√™n:
                    // 1. Ch√™nh l·ªách min-max (50%)
                    const rangeScore = Math.max(0, 100 - (maxQty - minQty) * 10);
                    
                    // 2. ƒê·ªô l·ªách chu·∫©n so v·ªõi trung b√¨nh (30%)
                    const variance = quantities.reduce((sum, qty) => sum + Math.pow(qty - avgQty, 2), 0) / n;
                    const stdDev = Math.sqrt(variance);
                    const stdScore = Math.max(0, 100 - stdDev * 20);
                    
                    // 3. S·ªë s·∫£n ph·∫©m c√≥ s·ªë l∆∞·ª£ng b·∫±ng nhau (20%)
                    const uniqueQtys = [...new Set(quantities)];
                    const equalityScore = Math.max(0, 100 - uniqueQtys.length * 15);
                    
                    return rangeScore * 0.5 + stdScore * 0.3 + equalityScore * 0.2;
                },
                
                calculateFinalScore(solution, target) {
                    const quantities = solution.quantities;
                    const n = quantities.length;
                    
                    // T√≠nh sai s·ªë cu·ªëi c√πng (bao g·ªìm VAT)
                    const actualVAT = Math.round(solution.total * this.vatRate / 100);
                    const totalWithVAT = solution.total + actualVAT;
                    const finalError = Math.abs(totalWithVAT - this.totalAmount);
                    
                    // 1. ƒêi·ªÉm sai s·ªë VAT (∆∞u ti√™n cao nh·∫•t) - 50%
                    const vatErrorScore = finalError < 1000 ? 50 : Math.max(0, 50 - finalError / 100);
                    
                    // 2. ƒêi·ªÉm c√¢n b·∫±ng s·ªë l∆∞·ª£ng - 40%
                    const maxQty = Math.max(...quantities);
                    const minQty = Math.min(...quantities);
                    const qtyDiff = maxQty - minQty;
                    const balanceScore = Math.max(0, 40 - qtyDiff * 5);
                    
                    // 3. ƒêi·ªÉm sai s·ªë target g·ªëc - 10%
                    const targetError = Math.abs(solution.total - target);
                    const targetErrorScore = Math.max(0, 10 - targetError / target * 100);
                    
                    return vatErrorScore + balanceScore + targetErrorScore;
                },
                
                fineTuneForVATError(products, solution, target) {
                    const n = products.length;
                    const quantities = [...solution.quantities];
                    let currentTotal = solution.total;
                    
                    const maxIterations = 100;
                    let bestError = Infinity;
                    let bestQuantities = [...quantities];
                    
                    // T√≠nh sai s·ªë VAT hi·ªán t·∫°i
                    const getCurrentVATError = (total) => {
                        const vat = Math.round(total * this.vatRate / 100);
                        return Math.abs((total + vat) - this.totalAmount);
                    };
                    
                    bestError = getCurrentVATError(currentTotal);
                    
                    for (let iter = 0; iter < maxIterations; iter++) {
                        let improved = false;
                        
                        // Th·ª≠ ƒëi·ªÅu ch·ªânh t·ª´ng s·∫£n ph·∫©m
                        for (let i = 0; i < n; i++) {
                            // Th·ª≠ tƒÉng
                            quantities[i]++;
                            const newTotal = currentTotal + products[i].price;
                            const newError = getCurrentVATError(newTotal);
                            
                            if (newError < bestError) {
                                bestError = newError;
                                bestQuantities = [...quantities];
                                currentTotal = newTotal;
                                improved = true;
                            } else {
                                quantities[i]--; // Ho√†n t√°c
                            }
                            
                            // Th·ª≠ gi·∫£m (n·∫øu > 1)
                            if (quantities[i] > 1) {
                                quantities[i]--;
                                const newTotal2 = currentTotal - products[i].price;
                                const newError2 = getCurrentVATError(newTotal2);
                                
                                if (newError2 < bestError) {
                                    bestError = newError2;
                                    bestQuantities = [...quantities];
                                    currentTotal = newTotal2;
                                    improved = true;
                                } else {
                                    quantities[i]++; // Ho√†n t√°c
                                }
                            }
                        }
                        
                        if (!improved || bestError < 1000) break;
                    }
                    
                    return {
                        quantities: bestQuantities,
                        total: bestQuantities.reduce((sum, qty, i) => sum + qty * products[i].price, 0)
                    };
                },
                
                groupProductsByPrice(products) {
                    const groups = [];
                    const used = new Array(products.length).fill(false);
                    
                    for (let i = 0; i < products.length; i++) {
                        if (used[i]) continue;
                        
                        const group = [i];
                        used[i] = true;
                        
                        for (let j = i + 1; j < products.length; j++) {
                            if (!used[j] && Math.abs(products[i].price - products[j].price) <= 1000) {
                                group.push(j);
                                used[j] = true;
                            }
                        }
                        groups.push(group);
                    }
                    
                    return groups;
                },
                
                findEqualQuantitySolution(products, target, baseQuantity) {
                    const n = products.length;
                    const quantities = new Array(n).fill(baseQuantity);
                    let currentTotal = quantities.reduce((sum, qty, i) => sum + qty * products[i].price, 0);
                    
                    // ƒêi·ªÅu ch·ªânh ƒë·ªÉ ƒë·∫°t target v·ªõi ƒë·ªô ∆∞u ti√™n: gi·ªØ s·ªë l∆∞·ª£ng ƒë·ªÅu > ƒë·∫°t target ch√≠nh x√°c
                    const maxIterations = 300;
                    for (let iter = 0; iter < maxIterations; iter++) {
                        const error = currentTotal - target;
                        
                        if (Math.abs(error) < target * 0.005) break; // Sai s·ªë < 0.5%
                        
                        if (error > 0) {
                            // C·∫ßn gi·∫£m - ch·ªçn s·∫£n ph·∫©m c√≥ gi√° cao nh·∫•t
                            let maxPriceIndex = 0;
                            for (let i = 1; i < n; i++) {
                                if (products[i].price > products[maxPriceIndex].price && quantities[i] > 1) {
                                    maxPriceIndex = i;
                                }
                            }
                            
                            if (quantities[maxPriceIndex] > 1) {
                                quantities[maxPriceIndex]--;
                                currentTotal -= products[maxPriceIndex].price;
                            } else {
                                break;
                            }
                        } else {
                            // C·∫ßn tƒÉng - ch·ªçn s·∫£n ph·∫©m c√≥ gi√° th·∫•p nh·∫•t
                            let minPriceIndex = 0;
                            for (let i = 1; i < n; i++) {
                                if (products[i].price < products[minPriceIndex].price) {
                                    minPriceIndex = i;
                                }
                            }
                            
                            quantities[minPriceIndex]++;
                            currentTotal += products[minPriceIndex].price;
                        }
                    }
                    
                    return {
                        quantities: quantities,
                        total: currentTotal
                    };
                },
                
                findGroupBalancedSolution(products, target, baseQuantity, priceGroups) {
                    const n = products.length;
                    const quantities = new Array(n).fill(baseQuantity);
                    let currentTotal = quantities.reduce((sum, qty, i) => sum + qty * products[i].price, 0);
                    
                    // ƒêi·ªÅu ch·ªânh theo nh√≥m gi√°
                    const maxIterations = 300;
                    for (let iter = 0; iter < maxIterations; iter++) {
                        const error = currentTotal - target;
                        
                        if (Math.abs(error) < target * 0.01) break;
                        
                        if (error > 0) {
                            // T√¨m nh√≥m c√≥ gi√° cao nh·∫•t ƒë·ªÉ gi·∫£m
                            let bestGroupIndex = -1;
                            let maxAvgPrice = 0;
                            
                            for (let g = 0; g < priceGroups.length; g++) {
                                const group = priceGroups[g];
                                const avgPrice = group.reduce((sum, idx) => sum + products[idx].price, 0) / group.length;
                                const canReduce = group.some(idx => quantities[idx] > 1);
                                
                                if (canReduce && avgPrice > maxAvgPrice) {
                                    maxAvgPrice = avgPrice;
                                    bestGroupIndex = g;
                                }
                            }
                            
                            if (bestGroupIndex >= 0) {
                                const group = priceGroups[bestGroupIndex];
                                // Gi·∫£m s·∫£n ph·∫©m c√≥ s·ªë l∆∞·ª£ng cao nh·∫•t trong nh√≥m
                                let maxQtyInGroup = 0;
                                let targetIndex = -1;
                                for (const idx of group) {
                                    if (quantities[idx] > maxQtyInGroup && quantities[idx] > 1) {
                                        maxQtyInGroup = quantities[idx];
                                        targetIndex = idx;
                                    }
                                }
                                
                                if (targetIndex >= 0) {
                                    quantities[targetIndex]--;
                                    currentTotal -= products[targetIndex].price;
                                } else {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            // T√¨m nh√≥m c√≥ gi√° th·∫•p nh·∫•t ƒë·ªÉ tƒÉng
                            let bestGroupIndex = -1;
                            let minAvgPrice = Infinity;
                            
                            for (let g = 0; g < priceGroups.length; g++) {
                                const group = priceGroups[g];
                                const avgPrice = group.reduce((sum, idx) => sum + products[idx].price, 0) / group.length;
                                
                                if (avgPrice < minAvgPrice) {
                                    minAvgPrice = avgPrice;
                                    bestGroupIndex = g;
                                }
                            }
                            
                            if (bestGroupIndex >= 0) {
                                const group = priceGroups[bestGroupIndex];
                                // TƒÉng s·∫£n ph·∫©m c√≥ s·ªë l∆∞·ª£ng th·∫•p nh·∫•t trong nh√≥m
                                let minQtyInGroup = Infinity;
                                let targetIndex = -1;
                                for (const idx of group) {
                                    if (quantities[idx] < minQtyInGroup) {
                                        minQtyInGroup = quantities[idx];
                                        targetIndex = idx;
                                    }
                                }
                                
                                if (targetIndex >= 0) {
                                    quantities[targetIndex]++;
                                    currentTotal += products[targetIndex].price;
                                } else {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                    }
                    
                    return {
                        quantities: quantities,
                        total: currentTotal
                    };
                },
                
                calculateSolutionScore(solution, target) {
                    const quantities = solution.quantities;
                    const n = quantities.length;
                    
                    // 1. ƒêi·ªÉm sai s·ªë (c√†ng nh·ªè c√†ng t·ªët) - tr·ªçng s·ªë 30%
                    const error = Math.abs(solution.total - target);
                    const errorScore = Math.max(0, 1 - error / target) * 30;
                    
                    // 2. ƒêi·ªÉm c√¢n b·∫±ng s·ªë l∆∞·ª£ng (ch√™nh l·ªách c√†ng nh·ªè c√†ng t·ªët) - tr·ªçng s·ªë 70%
                    const maxQty = Math.max(...quantities);
                    const minQty = Math.min(...quantities);
                    const qtyDiff = maxQty - minQty;
                    const balanceScore = Math.max(0, 1 - qtyDiff / Math.max(maxQty, 5)) * 70;
                    
                    return errorScore + balanceScore;
                },
                
                improveBalance(products, solution, target) {
                    const n = products.length;
                    const quantities = [...solution.quantities];
                    let currentTotal = solution.total;
                    let improved = true;
                    
                    const maxIterations = 200;
                    let iterations = 0;
                    
                    while (improved && iterations < maxIterations) {
                        improved = false;
                        iterations++;
                        
                        // T√¨m c·∫∑p s·∫£n ph·∫©m ƒë·ªÉ c√¢n b·∫±ng
                        for (let i = 0; i < n; i++) {
                            for (let j = 0; j < n; j++) {
                                if (i !== j && quantities[i] > quantities[j] + 1 && quantities[i] > 1) {
                                    // Th·ª≠ chuy·ªÉn 1 ƒë∆°n v·ªã t·ª´ i sang j
                                    const oldTotal = currentTotal;
                                    const newTotal = currentTotal - products[i].price + products[j].price;
                                    
                                    // T√≠nh ƒëi·ªÉm s·ªë tr∆∞·ªõc v√† sau
                                    const oldSolution = { quantities: [...quantities], total: oldTotal };
                                    const newQuantities = [...quantities];
                                    newQuantities[i]--;
                                    newQuantities[j]++;
                                    const newSolution = { quantities: newQuantities, total: newTotal };
                                    
                                    const oldScore = this.calculateSolutionScore(oldSolution, target);
                                    const newScore = this.calculateSolutionScore(newSolution, target);
                                    
                                    // Ch·ªâ ch·∫•p nh·∫≠n n·∫øu c·∫£i thi·ªán ƒëi·ªÉm s·ªë t·ªïng th·ªÉ
                                    if (newScore > oldScore) {
                                        quantities[i]--;
                                        quantities[j]++;
                                        currentTotal = newTotal;
                                        improved = true;
                                        break;
                                    }
                                }
                            }
                            if (improved) break;
                        }
                        
                        // N·∫øu kh√¥ng c·∫£i thi·ªán ƒë∆∞·ª£c b·∫±ng ho√°n ƒë·ªïi, th·ª≠ ƒëi·ªÅu ch·ªânh nh·ªè
                        if (!improved) {
                            const currentError = Math.abs(currentTotal - target);
                            
                            // Th·ª≠ ƒëi·ªÅu ch·ªânh ƒë·ªÉ gi·∫£m sai s·ªë m√† kh√¥ng l√†m m·∫•t c√¢n b·∫±ng qu√° nhi·ªÅu
                            for (let i = 0; i < n; i++) {
                                if (currentTotal < target) {
                                    // Th·ª≠ tƒÉng s·∫£n ph·∫©m c√≥ s·ªë l∆∞·ª£ng th·∫•p nh·∫•t
                                    const minQty = Math.min(...quantities);
                                    if (quantities[i] === minQty) {
                                        const newTotal = currentTotal + products[i].price;
                                        const newError = Math.abs(newTotal - target);
                                        
                                        if (newError < currentError) {
                                            quantities[i]++;
                                            currentTotal = newTotal;
                                            improved = true;
                                            break;
                                        }
                                    }
                                } else {
                                    // Th·ª≠ gi·∫£m s·∫£n ph·∫©m c√≥ s·ªë l∆∞·ª£ng cao nh·∫•t
                                    const maxQty = Math.max(...quantities);
                                    if (quantities[i] === maxQty && quantities[i] > 1) {
                                        const newTotal = currentTotal - products[i].price;
                                        const newError = Math.abs(newTotal - target);
                                        
                                        if (newError < currentError) {
                                            quantities[i]--;
                                            currentTotal = newTotal;
                                            improved = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    return {
                        quantities: quantities,
                        total: currentTotal
                    };
                }
            }
        }).mount('#app');
    </script>
</body>
</html>